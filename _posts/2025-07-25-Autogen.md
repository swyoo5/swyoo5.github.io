---
layout: single
title:  "[LLM] AutoGen vs LangGraph vs CrewAI"
categories: [Programming, LLM, RAG, Project]
tag: [Programming, LLM, RAG, Project]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# AutoGen

- 복잡한 작업을 여러 AI 에이전트 간의 대화로 모델링(Orchestration)
- 아키텍처 구성 요소
  - ConversableAgent : 메시지를 보내고, 받고, 처리할 수 있는 기본적인 에이전트 개체
  - AssistantAgent : 코드 작성, 질문 답변과 같은 특정 작업을 수행하도록 설계된 에이전트. 전문가 역할 수행
  - UserProxyAgent : 인간 사용자를 대신하는 프록시 역할, 코드 실행자로서 기능. 다른 에이전트가 생성한 코드 직접 실행
- 핵심 기능
  - RetrieveUserProxyAgent : 임베딩 유사도를 기반으로 문서 청크를 검색 → 이를 쿼리와 함께 AssistantAgent에 전달하여 답변 생성
  - retrieve_config : RAG 프로세스를 구성하기 위한 핵심 파라미터 집합. task(예:code), docs_path(문서 경로), chunk_token_size(청크 크기), model(시용 모델), chromadb와 같은 벡터 저장소 클라이언트를 상세하게 설정
  - Human in the loop : human_input_mode를 NEVER(완전 자율), TERMINATE(종료 조건 충족 시 개입), ALWAYS(항상 개입)로 설정. 인간의 개입 수준을 조절

# LangGraph

- 선형적인 LangChain의 한계 극복 → LLM 어플리케이션에 순환 구조 추가
- 아키텍쳐 구성 요소
  - StateGraph : 워크 플로의 구조를 담는 중심 클래스. 이 그래프는 상태 객체(예 : TypedDict)에 의해 매개변수화되며 이 상태는 각 노드를 거치면서 전달되고 업데이트됨
  - Nodes : 작업의 기본 단위. Python 함수 또는 LangChain Runnable 객체를 나타냄. 각 노드는 현재 상태를 입력으로 받아 상태에 대한 업데이트 반환
  - Edges : 노드를 연결하고 흐름 정의
    - Entry Point : set_entry_point()는 그래프의 시작점을 정의
    - Normal Edges : add_edge()는 한 노드에서 다른 노드로의 적접적인 경로 생성
    - Conditional Edges : add_conditional_edges()는 특정 함수의 출력값을 기반으로 워크플로를 동적으로 다른 하위 노드로 라우팅하여 분기, 루프, 의사결정을 가능하게 함
- 핵심 기능
  - Self-RAG, Corrective-RAG 패턴을 구현하는데 적합
    - 문서 평가 : 검색된 문서의 관련성을 평가하는 노드 생성. 조건부 엣지가 평가 등급을 확인 → 관련성이 높으면 생성 단계로 진행, 그렇지 않으면 쿼리 재작성 노드로 이동
    - Query Rewrite & Reranking

# CrewAI

- 아키텍처 구성 요소
  - Agent : role, goal, backstory는 단순히 서술적인 요소가 아니라 에이전트의 행동과 의사결정을 안내하는 프롬프트 생성
  - 작업 : description(설명) expected_output(예상 결과물)로 정의되며 특정 agent에게 할당됨
  - 도구 : 에이전트는 도구를 통해 강력한 기능을 부여받음. CrewAI는 RAG에 특화된 다수의 도구를 포함한 사전 구축 도구 라이브러리 제공
  - 프로세스(순차적 & 계층적)
    - 순차적 : 작업이 순서대로 실행, 한 작업의 결과가 다음 작업의 컨텍스트로 전달
    - 계층적 : 관리자 Agent가 작업자 Agent에게 작업을 위임하여 더 복잡하고 동적인 워크플로 가능하게 함
- 핵심 기능
  - 광범위한 플러그 앤 플레이 방식의 RAG 도구 라이브러리. EmgedChain을 래핑하여 파일, URL, 디렉터리 등에서 간단한 .add() 메서드만으로 쉽게 데이터 수집
  - 역할 기반 라우팅을 통한 에이전틱 RAG : 라우터 에이전트를 정의하여 에이전틱 RAG 시스템 구축. 에이전트의 role, goal은 들어오는 질문을 분석하고 어떤 도구를 갖춘 에이전트가 어떻게 처리해야 할 지 결정
- 추상화
  - CrewAI의 가장 큰 강점은 추상화
  - RAG의 근본적인 복잡성(청킹, 임베딩, 검색)을 숨긴다
  - self-RAG 파이프라인을 구현하기는 어려움 → LangGraph가 더 적합
  - CrewAI의 핵심 메커니즘은 role, goal, backstory

# 비교

- 추상화
  - LangGraph : 가장 낮은 수준의 추상화, 가장 높은 수준의 제어
  - AutoGen : 중간 수준의 추상화
  - CrewAI : 가장 높은 수준의 추상화, 가장 낮은 수준의 제어
- 워크플로우
  - LangGraph : 노드, 조건부 엣지로 구성된 명시적이고 순환적인 그래프
  - AutoGen : 자유로운 형태의 다중 에이전트 대화
  - CrewAI : 구조화되고 순차적이거나 간단한 계층적 구조의 작업 전달

# 목적에 따른 사용

- 표준 문서 Q&A
  - 특정 문서에 대해 질문에 답변하는 챗봇
  - 권장 프레임워크 : CrewAI
- 동적 도구 사용을 갖춘 Agent
  - 내부 지식 베이스 쿼리, 웹 검색, 계산 수행 등 도구 사용
  - 권장 프레임워크 : AutoGen
- self-RAG 파이프라인
  - 관련 없는 검색 결과를 처리하기 위해 문서 관련성 평가, 쿼리 재작성, 웹 검색과 같은 대체 메커니즘 사용
  - 권장 프레임워크 : LangGraph
-  HITL(Human In The Loop)
  - 법률, 의료 연구와 같이 민감한 분야에서 인간이 RAG 프로세스를 지속적으로 안내, 수정
  - LangGraph, AutoGen