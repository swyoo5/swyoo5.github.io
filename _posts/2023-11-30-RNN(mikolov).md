---
layout: single
title:  "11/30 [논문번역] Recurrent neural network based language model"
categories: [Programming, python, 논문, RNN]
tag: [Programming, python, 논문, RNN]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

 

# Recurrent neural network based language model(Tomas mikolov)

# Abstract

음성인식에 적용되는 새로운 RNNLM이 제시됐다. 결과는 몇개의 RNNLM들을 혼합해서 사용하면, 최신의 backoff language model과 비교했을 때, 50%정도의 perplexity 감소를 얻을 수 있음을 가리킨다. 음성인식 실험에서 같은 양의 데이터로 학습된 다른 모델과 비교했을 때, Wall Street Journal task에서 18% 정도의 단어 오류율 감소를 보여준다.  그리고 backoff model이 RNNLM보다 훨씬 많은 양의 데이터로 훈련됐음에도, RNNLM이 더 어려운 NIST RT05 task 에서도 5% 감소한 것으로 나타났다. 우리는 connectionist language model들이 표준적인 n-gram 기술들보다 계산적 복잡성을 제외하고 뛰어나다는 것을 보이기 위해 충분한 경험적 증거들을 제시한다..



backoff model : 특정 단어가 다음에 올 확률이 0인 상황인 경우에 N을 줄여서 희소성 문제를 해결하는 방법이다. 예를 들어, 원하는 단어가 없는 경우 N을 N - k로 줄여서 다시 확률 계산을 하는 방식이다. 이때 k값은 분모의 count 함수가 0이 되지 않는 최대의 자연수로 정한다. 이런 k는 N-1로 bounded 돼있으므로 항상 잡을 수 있다.(출처 : https://judia.tistory.com/2)



## 1. Introduction

  많은 사람들은 시계열 데이터 예측을 머신러닝과 인공지능의 중요한 문제로 간주한다. 확률적 언어 모델링의 목표는 주어진 문맥의 텍스트 데이터에서 다음 단어를 예측하는 것이다. 따라서 우리는 시계열 데이터 예측 문제를 언어모델을 구축할 때 다뤄야 한다. 아직 많은 통계적 모델을 얻으려는 많은 노력에는 언어 영역에 매우 특수한 접근 방식이 포함된다. 에를 들어, 자연어 문장이 parse tree로 묘사될 수 있다는 가정, 또는 단어, 문법 및 의미의 형태를 고려해야 한다는 가정이다. 심지어 n-gram 통계 기반의 가장 널리 사용되고 가장 일반적인 모델이라 할지라도, 언어는 atomic symbols - 단어(더이상 쪼개지지 않는 토큰)의 연속으로 이루어져 있다고 가정한다. 단어는 문장을 구성하고, EOS(end of sentence) symbol은 매우 중요하고 특별한 역할을 한다.

  단순한 n-gram 모델에 비해 언어 모델링에 상당한 진전이 있었는지 의문이다. 시계열 데이터를 더 잘 예측하는 모델의 능력으로 이러한 발전을 측정한다면, 그 답은 상당한 향상이 이루어졌다는 것이다 - 특히 cache models과 class based models의 도입에 의해 이루어졌다.다른 많은 기술들이 제안된 반면, 그들의 효과는 cache models(긴 문맥 정보를 묘사) 또는 class based models(비슷한 단어 간의 파라미터를 공유함으로써 짧은 문맥에 대한 파라미터 추정을 개선함)과 비슷했다.

  만약 발전한 언어모델링 기술의 성공을 실제 적용을 통해 측정하려면, 우리는 더 회의적이어야 한다. 실제 세상의 음성인식 또는 기계번역 시스템을 위한 언어 모델은 많은 양의 데이터로 구축되어 있고, 대중적인 믿음은 더 많은 데이터많이 우리에게 필요한 것이라고 한다. 연구에서 온 모델들은 복잡하고 매우 제한된 훈련 데이터 기반의 시스템에서만 잘 작동한다. 사실 대부분의 제안된 대부분의 언어 모델링 기술들은 단순한 baseline에 비해 아주 작은 개선만을 제공하며 실제로는 거의 사용되지 않는다.



baseline : 기계학습 프로젝트에서 비교대상이 되는 간단한 모델, 말 그대로 기준(base)이 되는 모델이다.



## 2. Model description

우리는 시계열 데이터를 모델링하기 위한 RNN을 조사하기로 결정했다. 통계적 언어 모델링에 인공신경망을 사용하는 것은 Bengio에 의해 이미 제안됐다. Bengio는 고정길이 문맥에서 피드포워드 신경망을 사용한 사람이다. 이러한 접근은 예외적으로 성공적이었고, Goodman에 의한 추가적인 조사에 따르면 이러한 단일 모델의 성능이 클래스 기반 모델을 포함한 다른 기술들을 기반으로 한 다른 몇몇 모델을 혼합한 것보다 성능이 우수하다. 나중에, Schwenk는 신경망 기반 모델들이 좋은 baseline 시스템에 비해 몇가지 작업에 대해 음성인식에서 상당한 향상을 제공한다는 것을 보여준다.

  Bengio의 접근방식의 중요한 결점은, 피드포워드 신경망은 훈련 이전에 즉석에서 특정되어야 하는 고정길이 context를 사용해야만 하는 것이다. 이 말은 신경망은 다음 단어를 예측할 때, 5-10개의 먼저 나타난 단어만 볼 수 있다는 것이다.  인간이 더 긴 문맥을 성공적으로 이용할 수 있다는 것은 사실이다. 또한 cache models은 신경망 모델에 보충 정보를 제공하기 때문에, 임의의 길이를 가진 문맥에 대해 시간 정보를 내부적으로 인코딩하는 모델을 생각하는 것은 자연스럽다. RNN은 고정된 길이의 문맥을 사용하지 않는다. 반복적은 연결을 사용함으로써, 정보는 임의적인 긴 시간동안 네트워크 안에서 순환한다. 하지만, 확률적 경서 하강법에 의해 long-term dependencies를 학습하는 것은 어렵다는 주장도 제기된다.

  우리의 연구에서 simple recurrent neural network 또는 Elman network라고 불리는 아키텍쳐를 사용했다. 이것은 RNN 중에서 가장 간단한 버전이고 구현, 학습이 매우 쉽다. 네트워크는 입력층 x, 은닉층 s, 출력층 y를 가진다. t시점에 네트워크의 입력값은 x(t), 출력값은 y(t), 은닉층은 s(t)라고 표시하겠다. 입력벡터 x(t)는 현재 단어를 나타내는 w벡터와 context층 s의 t-1시점에서의 뉴런으로부터 나온 출력을 연결함으로써 만들어진다. 입력, 은닉, 출력층은 다음과 같이 계산된다.
$$
x(t) = w(t) + s(t - 1)\\
s_j(t) = f(\sum_{i}x_i(t)u_{ji})\\
y_k(t) = g(\sum_{j}s_{j}(t)v_{kj})
$$
여기서 f는 시그모이드 함수, g는 소프트맥스 함수이다.



  처음에 s(0)은 0.1과 같은 매우 작은 값으로 설정할 수 있다. 많은 양의 데이터로 처리할 때, 초기값은 그렇게 중요하지 않다. 다음 시점에서 s(t + 1)은 s(t)가 된다. 입력벡터 x(t)는 1-of-N(a.k.a 원핫 인코딩)과 이전 context layer를 사용하여 인코딩된 시간 t의 단어를 나타낸다. 벡터 x의 크기는 단어의 개수 V와 context layer의 크기를 더한 값과 같다(V는 실제로 30,000 - 200,000정도의 범위). context(hidden) layer s의 크기는 보통 30-500개의 hidden unit들이 있다. 우리의 실험을 기반으로, 은닉층의 크기는 훈련 데이터의 양을 반영해야 한다. 많은 양의 데이터는 더 큰 은닉층을 필요로 한다.

  네트워크는 훈련 코퍼스의 모든 데이터가 순차적으로 나타나는 여러 에폭으로 훈련된다. 웨이트들은 작은 값으로 초기화된다(n(0, 0.1)을 따르는 값들). 네트워크를 훈련하기 위해서 우리는 확률적 경사 하강법을 사용하는 표준 역전파 알고리즘을 사용한다. 처음 학습률은 $alpha = 0.1$부터 시작한다. 각 에폭을 지나 네트워크를 검증 데이터로 테스트한다. 검증 데이터의 로그가능도가 증가하면 새로운 에폭으로 훈련을 계속한다. 특정 발전이 관측되지 않으면, 새로운 에폭이 시작될 때마다 학습률을 절반으로 줄인다. 그 후로 계속해서 특정한 발전이 없다면 훈련은 종료된다.  수렴은 보통 10-20에폭 후에 달성된다.

  우리의 실험에서, 네트워크는 매우 큰 은닉층을 사용하여도 크게 overtrain 되지 않는다(큰 weight에 대해 페널티를 주기 위한 네트워크의 정규화는 큰 개선을 가져다주지 않았다). 출력층 y(t)는 이전 단어 w(t)와 context s(t - 1)가 주어진 다음 단어의 확률 분포를 나타낸다. 소프트맥스 함수는 이 확률분포가 유효한 값인지 확인한다. 즉, 임의의 단어 m에 대해 $y_{m}(t) > 0$ 그리고 $\sum_{k}y_{k}(t) = 1$

  각 훈련 시점에서 오류 벡터는 크로스 엔트로피 표준에 따라 계산되고, weight값들은 역전파 알고리즘에 의해 업데이트된다.
$$
error(t) = desired(t) - y(t)
$$
desired는 원핫 인코딩을 이용해 특정 문맥에서 예측되어야 하는 단어를 나타낸 벡터이다. 그리고 y(t)는 네트워크로부터 나온 실제 출력값이다.

  통계적 언어 모델링에서 훈련 단계와 테스트 단계는 다르다는 것을 기억해라. 테스트 데이터가 진행됨에 따라서 모델은 업데이트되지 않는다. 따라서, 새로운 사람의 이름이 테스트 데이터에서 반복적으로 나타났다면, 그것이 알려진 단어일지라도 반복적으로 매우 작은 확률을 가질것이다. 장기 메모리는 context unit의 활성화가 아니라 시냅스 자체에 있어야 한다고 가정할 수 있다. 즉, 네트워크는 테스트 단계 중에도 훈련을 계속해야 한다. 우리는 이러한 모델을 동적모델이라고 부른다. 우리는 동적모델에게 학습률을 0.1로 고정시킨다. 훈련 단계에서는 모든 데이터는 여러 에포크에 걸쳐 네트워크에 제공되지만, 동적모델은 테스트 데이터를 처리할 때 한번만 업데이트된다. 이것은 당연히 최적의 해결책이 아니고, 앞으로 보겠지만 정적 모델에 대비해서 perplexity의 충분히 큰 감소를 가져다준다. 이러한 변형은 신경망이 연속공간에서 학습한다는 차이점을 제외하고 backoff 모델의 cache 기술과 매우 유사하다. 따라서 개와 고양이가 관련되어있는 경우 테스트 데이터에서 개가 자주 발생하면 고양이가 발생할 확률도 높아진다.

  그래서 동적으로 업데이트된 모델들은 새로운 영역에 자동적으로 적응한다. 하지만, 음성인식 실험에서 이력은 인식기가 제시한 가설로 표현되며, 인식 오류를 포함하고 있다. 이것은 일반적으로 ASR의 캐시 n-gram model들의 나쁜 성능을 초래한다.

  여기 설명된 훈련 알고리즘은 τ = 1을 사용한 truncated backpropagation through time(BPTT)이라고도 한다. 이것은 네트워크의 weight가 현재 시점에서만 계산된 에러 벡터를 기반으로 업데이트되기 때문에 최적이 아니다. 이러한 단순화를 극복하기 위해 BPTT알고리즘이 주로 사용된다.

  Bengio와 Schwenk에 의해 사용된 feed forward neural network와 RNN의 가장 큰 차이점은 훈련 전에 즉흥적으로 조정되거나 계산되어야 하는 parameter의 양이다. RNNLM은 hidden(context) layer의 크기만 선택되면 된다. feedforward network의 경우, 단어를 저차원 공간에 투영하는 계층의 크기, hidden layer와 context 길이를 조정해야 한다.



## 2.1 Optimization

성능을 향상시키기 위해 우리는 임계값보다 적게 발생하는 모든 단어들을 특별한 희소 토큰으로 합쳐야 한다. 단어의 확률은 다음과 같이 계산된다.

![rnn 논문리뷰 수식](/images/2023-11-30-RNN(mikolov)/rnn 논문리뷰 수식.jpg)

![rnn 논문리뷰 수식1](/images/2023-11-30-RNN(mikolov)/rnn 논문리뷰 수식1.jpg)여기서 c_rare은 단어 중에서 임계값보다 적게 발생한 단어의 개수를 의미한다. 모든 희소 단어는 동등하게 다뤄진다. 즉, 확률은 그들 사이에 동등하게 나눠진다.

  Schwenk는 성능의 향상을 위해 사용할 수 있는 몇가지 가능한 접근방법들을 설명한다. 추가적인 확률들은 10, 11, 12번 논문에서 다루고 대부분은 RNN에 적용된다. 비교해보면, brown corpus(80만개의 단어, 100개의 hidden unit, 단어 임계값은 5)에 기반한 RNN모델을 훈련하는데 6시간, 반면 Bengio 보고서는 비슷한 데이터를 사용하고 비슷한 크기의 신경망을 사용했을 때, 훈련하는데 113일 걸리고 importance sampling을 하는데 26시간이 걸렸다. 우리는 계산에 속도를 높이기 위해 BLAS 라이브러리를 사용한다.



## WSJ experiments

Simple RNN 기반 언어모델의 성능을 평가하기 위해 우리는 몇가지 표준 음성인식 작업을 선택했다. 첫째 우리는 DARPA WSJ'92와 WSJ'93 데이터로부터 상위 100개의 목록의 점수를 다시 메긴 후 결과를 보고한다. Xu와 Filimonov에 의해 같은 데이터가 사용되었다. Oracle WER(Word Error Rate)은 dev set(validation set) 6.1%, eval set 9.5%였다. 언어 모델을 위한 훈련 데이터들은 Xu에 의해 사용된 것과 같다.

  훈련 corpus는 English Gigaword의 NYT 섹션으로부터 온 37M개의 단어들로 구성되어있다. 이렇게큰 데이터에서 RNNLM을 훈련시키는 것은 시간이 많이 들기 때문에 훈련 RNN모델(300K개 문장)에서 6.4M개까지만 사용한다. 가장 복잡한 모델을 훈련하는 데 몇주가 걸린다. perplexity는 held out data(230K개 단어)에 의해 평가된다. 또한 우리는 혼합된 모델에 대한 결과도 보고한다. RNNLM의 경우 가중치 0.75, backoff LM의 경우 0.25인 선형 보간법이 모든 실험에 사용되었다. 추가적인 실험에서 우리는 변형된 Kneser-Ney smoothed 5-gram을 KN5로 나타낸다. RNN 90/2와 같은 신경망 LM들의 구성은 은닉층 크기가 90이고 단어를 희귀 토큰으로 합치는 임계값을 2라고 가리키는 것이다.인식기(recognizer)에 의해 사용된 데이터의 부분집합으로 훈련된 backoff model을 사용하 n-best list를 올바르게rescore하기 위해서 우리는 열린 단어 언어 모델(open vocabulary language models)을 사용해야 한다. 결과를 향상시키기 위해서 다른 아키텍쳐를 가진 다양한 RNNLM의 출력이 선형보간 할 수 있다(다양성은 무작위 가중치 초기화로도 제공된다).

  표 1, 2에 보고된 결과는 언어 모델링 기술을 단순히 변경하여 얻은 WSJ 작업에 대해 보고된 가장 큰 개선사항 중 하나가 아니다. 훈련 데이터가 증가함에 따라 개선이 커진다. 단순히 더 많은 데이터를 사용하면 훨씬 더 큰 개선이 이루어질 수 있음을 시사한다. 표 2에서처럼 수정된 Kneser-Ney smoothing을 사용한 5-gram에 대해 3개의 동적인 RNNLM을 혼합하여 사용할 때 WER 감소는 18%이다. 또한, perplexity 감소는 가장 크고 KN 5-gram과 3개의 동적인 RNNLM을 비교했을 때 거의 50%가 감소했다. 사실 테스트 데이터를 처리할 때 큰 학습률(0.3)을 사용하여 동적, 정적 RNNLM을 혼합한 결과 가장 낮은 perplexity는 112였다.

  이때까지의 실험의 모든 LM들은 같은 작업을 하기 위해 다른 사람들이 사용한 단어의 양에 비하면 매우 적은 6.4M개의 단어로 훈련되었다. Xu와 Filimonov를 비교하기 위해 우리는 backoff 모델 기반의 37M개의 단어를 사용하였다(Xu는 같은 데이터를 사용하였고, Filimonov는 70M개의 단어를 사용했다). 결과는 Table3에 나와있고 RNN기반의 모델은 5배 더 많은 데이터로 훈련된 backoff model에 비교했을 때, 상대적으로 WER을 약 12% 감소할 수 있음을 결론지을 수 있다.



![rnn 논문리뷰 수식2](/images/2023-11-30-RNN(mikolov)/rnn 논문리뷰 수식2.jpg)



## 4. NIST RT05 experiments

  이전 실험에서는 공평한 baseline에 비해 매우 흥미로운 개선이 나타난 반면, 합당한 비판이 있을 수 있는 점이 실험에 사용된 acoustic model이 최신기술과 거리가 멀다는 점이다. 그리고 아마도 이러한 경우에 개선을 얻는 것이 잘 조정된 시스템을 개선하는 것보다 쉬울것이다. 더욱 중요한 것은 기준 backoff model을 훈련하는 데 사용되는 37M 또는 70M개의 단어가 작업에 가능한 것보다 훨씬 적다는 사실이다.

  최첨단 시스템에서의 의미있는 개선을 얻을 수 잇다는 것을 보여주기 위해 NIST RT05 평가에 사용된 AMI 시스템에서 생성된 격자로 실험했다. 테스트 데이터는 독립적인 헤드셋 조건에 대한 NIST RT05 평가였다.

  acoustic HMM은  MPE(Most Probable Explanation) 기준을 사용하여 차별적으로 훈련된 cross-word tied-states triphones를 기반으로 한다. 특징 추출은 델타, HLDA에 의해 39차원 특징 벡터로 감소된 이중 및 삼중 델타를 포함한 13 Mel-PLP의 특징을 사용한다. Mel filterbank의 출력에는 VLTN warping factor가 적용되었다. 훈련 데이터의 양은 ICSI, NIST, ISL 그리고 AMI 훈련 corpora로부터의 훈련 corpora의 115시간 회의 연설이었다.

  AMI 시스템에 사용된 4-gram LM은 다양한 데이터 소스로부터 훈련되었다. LM 훈련 데이터의 총 양은 1.3G개보다 많다. 이 LM은 표 4의 RT05 LM으로 표시된다. RT09 LM은 추가적인 CHIL 그리고 웹 데이터로 확장된다. 다음 변경사항은 컷오프를 낮추는 것이었다. 4-gram의 최소 개수가 4가 아닌 3으로 설정되었다. RNNLM을 훈련하기 위해 회의 전문과 Switchboard corpus(합계 5.4M개의 단어)로 이루어진 도메인 데이터를 고른다. RNN 훈련은 더 많은 데이터와 하면 너무 많은 시간이 걸린다. 이는 RNN이 RT05 및 RT09 LM을 구성하는데 사용되는 데이터의 작은 하위 집합에 대해 훈련된다는 것을 의미한다.



* acoustic model : 음향 신호와 음소 또는 음성을 구성하는 다른 언어 단위간의 관계를 나타내기 위해 음성 인식에 사용된다. 쉽게 말해서 주어진 문장에 대한 음성의 특징벡터의 분포를 계산해주는 모델이다.



* HMM(Hidden Markov Model) : 

  https://dongchans.github.io/2019/115/

  https://ratsgo.github.io/machine%20learning/2017/03/18/HMMs/



![rnn 논문리뷰 수식3](/images/2023-11-30-RNN(mikolov)/rnn 논문리뷰 수식3.jpg)



## 5. Conclusion and future work

RNN이 모든 실험에서 back off 모델의 상태보다 훨씬 더 나은 성능을 보였고 특히 backoff model이 RNNLM보다 훨씬 더 많은 데이터에 대해 훈련된 경우도 마찬가지였다. WSJ 실험에서 WER 감소는 같은 양의 데이터에 대해 학습한 모델의 경우 약 18%. RNN 모델보다 5배 많은 데이터를 학습시킨 backoff model의 경우 12%였다. NIST RT05의 경우 도메인 내 데이터 5.4M개를 학습시킨 모델이 100배 많은 데이터를 학습시킨 backoff model들보다 성능이 뛰어났다. 얻은 결과는 언어 모델은 n-gram을 세는것에 관한 것이고 결과를 향상시키는 방법은 새로운 훈련 데이터를 얻는것이라는 미신을 깬다.

  표 2에 나타난 Perplexity 개선은 비슷한 데이터 셋에서 가장 큰 것 중 하나이며 온라인 학습(이 논문에서는 동적 모델이라고 하며, 음성 인식의 맥락에서 비지도 LM 기술과 매우 유사하다.)의 매우 중요한 효과가 있다. WER이  약간의 영향을 받고 테스트 데이터의 올바른 순서를 필요로 하지만, 온라인 학습은 cache-like, trigger-like 정보를 얻는 자연스러운 방법을 제공하므로 추가적인 조사가 필요하다. 만약 언어를 정말 배울 수 있는 모델을 만들고 싶아면 온라인 학습은 중요하다. 새로운 정보를 획득하는 것은 매우 중요하다.



* 온라인 학습 : 딥러닝에서 모델을 점진적으로 학습시키는 방법 중 하나로 데이터가 도착하는 대로 모델을 업데이터하며, 새로운 데이터 하나가 들어올 때마다 모델이 즉시 학습을 수행한다.
  * 점진적인 업데이트 : 새로운 데이터가 도착할 때마다 모델의 가중치를 조정하여 학습을 계속 진행한다.
  * 메모리 효율성 : 전체 데이터셋을 메모리에 한번에 로드하지 않고 필요한 만큼의 데이터를 이용하여 모델을 업데이트하므로 효율이 좋다.
  * 실시간 학습 : 실시간으로 발생하는 데이터에 대해 모델을 실시간으로 학습시킬 수 있다.
  * 변화에 빠르게 적응 : 데이터의 변화에 빠르게 적응할 수 있어 동적인 환경에서 유용하다.

  RNN 학습을 위한 BPTT에 대한 추가적인 조사가 추가적인 개선을 만들 가능성이 있다. toy task의 예비적인 결과는 유망하다. 하지만 simpleRNN은 매우 긴 문맥 정보를 유지하는 것처럼 보이지 않는다. 동적 모델들이 BPTT로 훈련되었다 하더라도 cache 모델들은 여전히 부가적인 정보를 제공하기 때문이다.

  우리의 연구에서 어떠한 task 나 language specific assumption을 만들지 않았기 때문에 기계번역이나 OCR같은 backoff language model을 사용하는 어떠한 종류의 적용에서 RNN기반 모델을 매우 쉽게 사용할 수 있다. 특히 굴절어 또는 사이즈가 큰 단어를 포함하는 task의 경우 NN기반 모델을 사용하는 것이 이득이다.

  우리의 연구에서 보고된 매우 좋은 결과 외에도 우리는 제안된 RNN모델이 흥미로웠다. 왜냐하면 언어 모델링을 머신러닝, 데이터 압축, 인지과학 연구에 더 가깝게 연결시켜주기 때문이다. 우리는 이러한 연결이 미래에 더 잘 이해할 수 있기를 바란다.



# Summary

기존의 n-gram 기반의 언어 모델링 기술보다 더 나은 성능을 보이는 새로운 순환 신경망 기반 언어 모델링 기술을 제안하고, 이 기술이 WSJ, NIST RT05와 같은 음성인식 분야에서 어떻게 적용될 수 있는지에 대한 실험결과를 제시했다. 이 논문은 이러한 새로운 기술이 언어 모델링 분야에서 더 나은 성능을 보이며, 더 많은 연산량을 필요로 하지만 이를 극복하기 위한 다양한 방법들이 제시될 수 있다는 것을 보여준다. 이러한 결과는 기존의 언어 모델링 기술을 개선하고, 음성인식 분야에서 더 나은 성능을 보이는 새로운 기술을 개발하는데 중요한 역할을 할 것이다.