---
layout: single
title:  "정보처리기사 실기 2022년-3회"
categories: [Programming, 자격증]
tag: [Programming, 자격증]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 2022-3회

## 1. C(어려움)

```C
void main() {

    int field[4][4] = {{0, 1, 0, 1}, {0, 0, 0, 1}, {1, 1, 1, 0}, {0, 1, 1, 1}};
    int mines[4][4] = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}};
    int w = 4, h = 4;
    int x, y, i, j;
    
    for (y = 0; y < h; y++) { 
        for (x = 0; x < w; x++) { 
            if (field[y][x] == 0) continue;

            for (i = y - 1; i <= y + 1; i++) { 
                for (j = x - 1; j <= x + 1; j++) { 
                    if (calculate(w, h, j, i) == 1) {
                        mines[i][j] += 1;
                    }
                }
            }
        }
    }

    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            printf("%d", mines[y][x]);
        }
        printf("\n");
    }
}

int calculate(int w, int h, int j, int i) {
    if (i >= 0 && i < h && j >= 0 && j < w) {
        return 1;
    }
    return 0;
}

```

```C
int field[4][4] = {{0, 1, 0, 1}, {0, 0, 0, 1}, {1, 1, 1, 0}, {0, 1, 1, 1}};
int mines[4][4] = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}};
```

코드를 해석해보면 그렇게 까다롭지 않지만 시험장에서 보면 시간도 뺏기고 당황할 수 있는 문제인 것 같다.

처음 두개의 중첩된 반복문은 배열의 모든 요소를 돌아보는 반복문이다. 그 다음 중첩된 두개의 반복문은 자기 자신을 포함해 이웃한 원소들을 모두 돌아보는(대각선 포함) 반복문이다. 즉, x행 y열을 돌 때 표와 같이 아홉개의 원소를 모두 돌아보는 것이다.

| a\[x-1\]\[y-1\] | a\[x-1\]\[y\] | a\[x-1\]\[y+1\] |
| :-------------: | :-----------: | :-------------: |
|  a\[x\]\[y-1\]  |  a\[x\]\[y\]  |  a\[x\]\[y+1\]  |
| a\[x+1\]\[y-1\] | a\[x+1\]\[y\] | a\[x+1\]\[y+1\] |

이렇게 돌아봤을 때 자기 자신을 포함한 9개의 원소 중 1이 있다면 mines\[x\]\[y\]에 1인 원소들의 개수를 적어주면 된다.

그럼 정답은

```
[[1, 1, 3, 2],
 [3, 4, 5, 3],
 [3, 5, 6, 4],
 [3, 5, 5, 3]]
```

## 3. 디자인 패턴

(  1  )은/는 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별한다. 

구현뿐 아니라 추상화도 독립적 변경이 필요할 때 브리지 패턴을 사용한다.
기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용하며,
새로운 인터페이스를 정의하여 기존 프로그램의 변경 없이 기능을 확장할 수 있다.

 

(  2  )은/는 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달해주는 패턴이다.
일대다 관계를 가지며, ​주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다.

1. Bridge
2. Observer
