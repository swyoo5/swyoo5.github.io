---
layout: single
title:  "정보처리기사 실기 2023년-2회"
categories: [Programming, 자격증]
tag: [Programming, 자격증]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 2023-2회

## 2. 괄호 안의 코드 작성

```java
public class Problem{
    public static void main(String[] args){
 m = 4620;
 
 a = ();
 b = ();
 c = ();
 d = ();
 
 System.out.println(a); //천원짜리     4장 출력
 System.out.println(b); //오백원짜리  1개 출력
 System.out.println(c); //백원짜리     1개 출력
 System.out.println(d); //십원짜리     2개 출력
    }
}
```

a = (m / 1000)

b = (m % 1000) / 500

c = (m % 500) / 100

d = (m % 100) / 10

## 3. C

```C
#include<stdlio.h> 
#include<stdlib.h> 
char n[30];
char *test() {
    printf(입력하세요 : );
    gets(n);
    return n;
}

int main()
{
    char * test1;
    char * test2;
    char * test3;
 
    test1 = test();
    test2 = test();
    test3 = test();
 
    printf(%s\n,test1);
    printf(%s\n,test2);
    printf(%s,test3);
}

```

test1때 홍길동, test2때 김철수, test3때 박영희가 입력되지만 배열 n이 전역변수로 선언되어 있어 마지막에 입력된 박영희로 덮어씌워짐 =>

결과 : 

박영희

박영희

박영희

## 5. C

```C
int n[3] = [73, 95, 82] 
sum = 0 
 
for(i=0;i<3;i++){
    sum += n[i];
}
 
switch(sum/30){
    case 10:
    case 9: printf("A");
    case 8: printf("B");
    case 7: 
    case 6: printf("C");
    default: printf("D");
```

sum = 73 + 95 + 82 = 250

sum / 30 = 8

case 8, 7, 6, default 모두 실행 => BCD

## 6. 테스트 커버리지

- 프로그램 내에 있는 결정포인트 내의 모든 각 개별 조건식에 대한 모든 가능한 결과(참/거짓)에 대해 적어도 한번 수행한다.

- 소프트웨어 테스트 수행시 소스코드를 어느 수준까지 수행하였는가를 나타내는 기준을 나타낸다. 

- 실제 업무에서는 다양한 툴을 사용하여 테스팅 수행한다.

- True/False에충분한 영향을 줄 수 없는 경우가 발생 가능한 한계점을 지닌다. 

  **조건 커버리지**

1. 구문 커버리지 

   모든 명령문 **적어도 한번** 수행

2. 결정 커버리지

   결정 포인트 내의 **전체 조건식**이 **적어도 한번은 참과 거짓**의 결과를 수행

3. 조건 커버리지

    결정 포인트 내의 각 **개별 조건식**이 **적어도 한번은 참과 거짓**의 결과를 수행

4. 조건/결정 커버리지  

   **전체 조건식**뿐만 아니라 **개별 조건식**도 **참과 거짓**의 결과를 수행

5. 변형 조건/결정 커버리지  

   **개별 조건식**이 다른 개별 조건식에 영향을 받지 않고 **전체 조건식에 독립적으로 영향**을 주도록 향상시킨 커버리지

6. 다중 조건 커버리지 

   모든 개별 조건식의 모든 **가능한 조합을 100% 보장**하는 커버리지

7. 기본 경로 커버리지 

   수행 가능한 **모든 경로를 테스트**하는 커버리지

8. 제어 흐름 커버리지

   프로그램 **제어 구조**를 **그래프 형태**로 나타내어 내부 로직 테스트

9. 데이터 흐름 커버리지

   **제어 흐름** 그래프에 **데이터 사용현황**을 추가한 그래프 테스트

## 8. 용어

- 소프트웨어에서 워터마크 삭제등과 같이 소프트웨어가 불법으로 변경(unauthorized modifications)되었을 경우, 그 소프트웨어가 정상 수행되지 않게 하는 기법이다.

- 소프트웨어 변조 공격을 방어하기 위해 프로그램에 변조검증코드(tamper-proofing code)를 삽입하는 것도 한 방법으로

- 변조검증코드의 용도는 첫째 프로그램이 변경되었는지를 탐지하는 것이고, 둘째는 변조가 탐지되었다면 프로그램이 실행되지 않게 한다.

- 소프트웨어의 위변조 방지 역공학 기술의 일종으로 디지털 콘텐츠의 관련 산업이나 전자상거래 또는 보호해야 할 소프트웨어가 있는 다양한 산업 분야에 적용된다.

  **템퍼 프루핑**

## 9. C

```C
#include <stdio.h>
#define MAX_SIZE 10
 
int isWhat[MAX_SIZE];
int point= -1; 
 
void into(int num) {
    if (point >= 10) printf("Full");
    isWhat[++point] = num;
}
 
int take() {
    if (isEmpty() == 1) printf("Empty");
    return isWhat[point--];
}
 
int isEmpty() {
    if (point == -1) return 1;
    return 0;
}
 
int isFull() {
    if (point == 10) return 1;
    return 0;
}
 
int main(int argc, char const *argv[]){
    int e;
    into(5); into(2); // [5, 2]
    while(!isEmpty()){
        printf("%d", take());
        into(4); into(1); printf("%d", take()); 
        into(3); printf("%d", take()); printf("%d", take()); 
        into(6); printf("%d", take()); printf("%d", take()); 
    }
    return 0;
}
```

* stack의 push와 pop 함수

  반복1 : [5, **2**] => [5] => [5, 4, **1**] => [5, 4] => [5, **4**, **3**] => [5] => [**5**, **6**] => []

  출력 : 213465

## 10. DB 설계

![image-20241015120139715](/images/2024-10-14-23년2회/image-20241015120139715.png)

요구조건 분석 => 개념 => 논리 => 물리 => 구현

## 11. 디자인패턴

1.

- 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.
- 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용한다.

**singleton**

2.

- 호스트 객체의 내부 상태에 접근할 수 있는 방법을 제공하여 호스트 객체에 연산을 추가할 수 있도록 한다.
- 이 패턴은 보통 합성 구조의 원소들과 상호 작용하는 데 사용되며, 기존 코드를 변경하지 않고 새로운 기능을 추가하는 방법이다.

**Visitor**

보기

| 생성패턴       | 구조패턴  | 행위패턴 |
| -------------- | --------- | -------- |
| Singleton      | Adapter   | Observer |
| Factory Method | Bridge    | Strategy |
| Builder        | Decorator | Visitor  |

[디자인패턴 정리 참고](https://velog.io/@bonni/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EC%A0%95%EB%A6%AC)

## 12. 용어

( 1 ) Code는 데이터 전송시 **1 비트의 에러를 정정**할 수 있는, 오류정정부호의 일종으로 미국의 Bell 연구소의 Hamming에 의해 고안되었다.
선형블록부호 및 순회부호에 속에 속한다.

* Hamming

* 추가설명

  수신측에서 직접 자기 정정 부호의 하나로 오류를 검출하고 수정까지 함

  Hamming distance : 송, 수신 데이터의 각 대응 비트가 서로다른 비트의 수 

  ex) 1101 송신, 1011 수신 => 해밍거리 = 2

( 2 ) 은/는 송신측이 전송할 문자나 프레임에 부가적 정보(Redundancy)를 첨가하여 전송하고 수신측이 이 부가적 정보를 이용하여 에러검출 및 에러정정을 하는 방식이다.

* FEC

* 추가설명

  재전송 요구 없이 수신 측에서 스스로 오류 검출 및 수정하는 방식

  에러 발생할 경우 송신측에 통보하지 않음

  오류정정을 위한 제어비트가 추가되어 효율이 떨어짐

  해밍코드, 상승코드 방식이 있음

( 3 ) 은/는 공격자가 전자 메일을 사용하여 상대방이 금전을 보내거나 기밀 회사 정보를 누설하도록 유도하는 사이버 범죄의 일종이다.

공격자는 신뢰할 수 있는 인물로 가장한 다음 가짜 청구서의 지불을 요청하거나 다른 사기에서 사용할 중요한 데이터를 요구한다.

* BEC

* 추가설명

  송신측에 재전송을 요구하는 방식

  패리티검사, CRC, 블록 합 방식으로 오류 검출

  오류 제어는 자동 반복 요청 ARQ에 의해 이루어짐

( 4 ) 은/는 데이터가 저장장치 내의 한 장소에서 다른 장소로 이동되거나, 컴퓨터들간에 전송될 때, 데이터가 유실 또는 손상되었는지 여부를 점검하는 기술과 관련된 용어이다.

* parity

* 추가설명

  전송 비트에 1비트의 패리티 비트를 추가하여 에러 발생 유무 판별

  홀수 패리티 검사를 한다면 1의 수가 홀수여야 함

  짝수 수직 패리티 검사를 블록 합 검사 Block Sum Check

( 5 ) 은/는 네트워크 등을 통하여 데이터를 전송할 때 전송된 데이터에 오류가 있는지를 확인하기 위한 체크값을 결정하는 방식을 말한다.

* CRC

* 추가설명

  다항식 코드를 사용하여 에러 발생 유무만 판별

  집단오류 검출 가능, 검출률이 높아 HDLC 프레임의 FCS(프레임검사순서필드)에 사용

* 보기

EAC, FEC, hamming, CRC, PDS, parity, BEC

1. hamming

2. FEC

3. BEC

4. parity

5. CRC

6. EAC

   이메일 어카운트 침해

7. PDS


## 13. HDLC 프로토콜

( 1 ) 프레임은 **Seq, Next, P/F**의 필드를 가진다. 또한 맨 처음 비트를 0으로 가진다. Seq는 송신용 순서번호를 가지고 있다. Next는 응답용 순서번호를 가진다. P/F는 **P가 1**로 설정된 경우 주국에서 **종국에 데이터 전송을 허용**하는 것을 의미하고 **F가 1**로 설정된 경우 **종국에서 주국으로 데이터 전송**을 하는 것을 의미한다.


( 2 ) 프레임은 맨 앞의 필드가 1로 되어 있어 정보 프레임이 아니라는 것을 나타내고 다음 비트가 0이 나와있다. Type의 경우에는 2비트를 가지고 있어 4가지의 종류로 나누어진다. 데이터를 보내는 역할이 아니라 응답의 기능을 수행하므로**Seq에 대한 값은 필요가 없고** 다음 프레임을 요구하는 **Next만 존재**한다.


( 3 ) 프레임은 **순서 번호가 없는 프레임**을 의미한다. 첫 번째 비트와 두 번째 비트가 모두 1로 설정되어 있다. 여러 종류를 가지고 있는데 Type의 2비트와 Modifier의 3비트를 합쳐 5비트를 통해 종류를 나눈다.


( 4 ) 은/는 두 호스트 모두 **혼합국으로 동작**한다. **양쪽에서 명령과 응답을 전송**할 수 있다.


( 5 ) 은/는 **불균형 모드**로 **주국의 허락 없이 종국에서 데이터를 전송**할 수 있다.

ㄱ. 연결제어   ㄴ. 감독   ㄷ. 정보   ㄹ. 양방향 응답   ㅁ. 익명   ㅂ. 비번호
ㅅ. 릴레이  ㅇ. 동기균형   ㅈ. 동기응답  ㅊ. 비동기균형   ㅋ. 비동기응답

1. ㄷ-정보

2. ㄴ-감독

3. ㅂ-비번호

4. ㅊ-비동기균형

5. ㅋ-비동기응답

   

# 14. JAVA

```Java
public class Main{
    public static void main(String[] args) {
        
        String str1 = 'Programming';
        String str2 = 'Programming';
        String str3 = new String('Programming');
        
        println(str1==str2)
        println(str1==str3)
        println(str1.equals(str3))
        print(str2.equals(str3))
    }
}
```

정답 : 

true

false

true

true

해설 : 

나머지는 맞춰서 첫번째 println만 설명하겠다. str1와 str2는 문자열 리터럴 풀(String Pool)에 저장된다. 자바는 동일한 문자열 리터럴이 반복해서 생성되는 것을 방지하기 위해 문자열 리터럴을 풀에 캐시한다. 따라서 str1과 str2는 같은 객체를 참조하므로 true

new 연산자를 통해 문자열 객체를 생성하는 경우 메모리의 heap 영역에 할당된다.

그림으로 표현하면 다음과 같다. 그림에서 str1과 str2는 리터럴 방식으로 생성, str3와 str4는 new를 통해 생성한 경우이다.

![image-20241015211101672](/images/2024-10-14-23년2회/image-20241015211101672.png)

## 15. 암호화 알고리즘

**15. 다음 보기는 암호화 알고리즘에 대한 내용이다. 대칭키와 비대칭키에 해당하는 보기의 내용을 작성하시오**

 

대칭키 : (       )

비대칭키 : (          )



### 보기

DES, RSA, AES, ECC, ARIA, SEED

대칭 : DES, AES, ARIA, SEED

비대칭 : RSA, ECC



## 16. 용어

- ( ) 란 임의의 크기를 가진 데이터(Key)를 고정된 크기의 데이터(Value)로 변화시켜 저장하는 것이다.
- 키에 대한 ( ) 값을 사용하여 값을 저장하고 키-값 쌍의 갯수에 따라 동적으로 크기가 증가한다.
- ( ) 값 자체를 index로 사용하기 때문에 평군 시간복잡도가 O(1) 로 매우 빠르다
- ( ) 함수는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다.
- ( ) 함수는 큰 파일에서 중복되는 레코드를 찾을 수 있기 때문에 데이터베이스 검색이나 테이블 검색의 속도를 가속할 수 있다.

정답 : hash, 해시, 해싱



## 19. 파이썬

```python
a = "engineer information processing"
b = a[:3]
c = a[4:6]
d = a[28:]
e=b+c+d
print(e)
```

b = "eng"

c = "ne"

d = "ing"

e = "engneing"

## 20. 용어

1.

- 하향식 테스트 시 상위 모듈은 존재하나 하위 모듈이 없는 경우의 테스트를 위해 임시 제공되는 모듈이다.
- 특별한 목적의 소프트웨어를 구현하는 것으로 컴포넌트를 개발하거나 테스트할 때 사용된다.
- 서버-클라이언트 구조에서 서버만 구현된 상태로 테스트를 해보고 싶을때 단순히 값만 넘겨주는 가상의 클라이언트를 만들어서 테스트 할 수 있다.

 **스텁**

2.

- 상향식 테스트 시 상위 모듈 없이 하위 모듈이 존재할 때 하위 모듈 구동 시 자료 입출력을 제어하기 위한 제어 모듈(소프트웨어)이다.
- 서버-클라이언트 구조에서 클라이언트만 구현된 상태로 테스트를 해보고 싶을때 접속 인증 등의 간단한 기능만 하는 가상의 서버를 만들어서 테스트 할 수 있다.

**드라이버**