---
layout: single
title:  "11/10 Dynamic Programming"
categories: [Programming, Java, CodingTest, Algorithm, DP]
tag: [Programming, Java, CodingTest, Algorithm, DP]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---



#  이코테 8-2

## 문제

* 1로 만들기

  정수 x가 주어질 때 사용할 수 있는 연산은 4가지이다

  1. 5로 나누어떨어지면 5로 나눔

  2. 3으로 나누어떨어지면 3으로 나눔

  3. 2로 나누어떨어지면 2로 나눔

  4. 1을 뺀다

  정수 x를 1로 만들려고 할 때 사용하는 연산의 최솟값을 출력하시오

* 설명

  이 문제는 Dynamic Programming의 잘 알려진 예제 중 하나로, memoization 기법을 이용해 숫자 1의 최소 연산 횟수를 시작으로 bottom-up 방식(상향식)으로 계산을 해나가서 원하는 숫자의 최소 연산 횟수를 구한다.

## 풀이

기록을 남겨두는 배열의 이름을 dp라고 하자.

dp[1] = 0 : 1이 주어졌을 때, 1이 되기위한 최소 연산 횟수는 0이다.

dp[2] = dp[1] + 1 or dp[2/2] + 1

dp[2]에 해당하는 두 식이 수학적으로 봤을 때 의미는 같지만, 문제를 보면 2에서 1이 되기 위해 어떻게 했는지 중간과정을 나타내는 식이다. 첫번째 식은 -1 연산, 두번째 식은 /2 연산을 수 행했을 때이다. 이런식으로 1을 뺐을 때 또는 나누어 떨어지는 수가 있다면 나눗셈을 했을 때 횟수를 각각 구해서 둘 중 작은 값을 선택하면 된다.

```java
public class DP {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int[] dp = new int[x + 1];
        
        for (int i = 2; i < x + 1; i++) {
            dp[i] = dp[i - 1] + 1; // -1 연산
            
            if (i % 5 == 0) {
                dp[i] = Math.min(dp[i], dp[i / 5] + 1);
            }
            
            if (x % 3 == 0) {
                dp[i] = Math.min(dp[i], dp[i / 3] + 1);
            }
            
            if (x % 2 == 0) {
                dp[i] = Math.min(dp[i], dp[i / 2] + 1);
            }
        }
        
        System.out.println(dp[x]);
    }
}
```



