---
layout: single
title:  "정보처리기사 실기 2022년-3회"
categories: [Programming, 자격증]
tag: [Programming, 자격증]
toc: true
author_profile: false
sidebar:
    nav: "docs"

---



# 2022-3회

## 1. C

{% raw %}

```C
void main() {

    int field[4][4] = {{0, 1, 0, 1}, {0, 0, 0, 1}, {1, 1, 1, 0}, {0, 1, 1, 1}};
    int mines[4][4] = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}};
    int w = 4, h = 4;
    int x, y, i, j;
    
    for (y = 0; y < h; y++) { 
        for (x = 0; x < w; x++) { 
            if (field[y][x] == 0) continue;

            for (i = y - 1; i <= y + 1; i++) { 
                for (j = x - 1; j <= x + 1; j++) { 
                    if (calculate(w, h, j, i) == 1) {
                        mines[i][j] += 1;
                    }
                }
            }
        }
    }

    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            printf("%d", mines[y][x]);
        }
        printf("\n");
    }
}

int calculate(int w, int h, int j, int i) {
    if (i >= 0 && i < h && j >= 0 && j < w) {
        return 1;
    }
    return 0;
}

```



```C
int field[4][4] = {{0, 1, 0, 1}, {0, 0, 0, 1}, {1, 1, 1, 0}, {0, 1, 1, 1}};
int mines[4][4] = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}};
```

{% endraw %}

코드를 해석해보면 그렇게 까다롭지 않지만 시험장에서 보면 시간도 뺏기고 당황할 수 있는 문제인 것 같다.

처음 두개의 중첩된 반복문은 배열의 모든 요소를 돌아보는 반복문이다. 그 다음 중첩된 두개의 반복문은 자기 자신을 포함해 이웃한 원소들을 모두 돌아보는(대각선 포함) 반복문이다. 즉, x행 y열을 돌 때 표와 같이 아홉개의 원소를 모두 돌아보는 것이다..

| a\[x-1\]\[y-1\] | a\[x-1\]\[y\] | a\[x-1\]\[y+1\] |
| :-------------: | :-----------: | :-------------: |
|  a\[x\]\[y-1\]  |  a\[x\]\[y\]  |  a\[x\]\[y+1\]  |
| a\[x+1\]\[y-1\] | a\[x+1\]\[y\] | a\[x+1\]\[y+1\] |

이렇게 돌아봤을 때 자기 자신을 포함한 9개의 원소 중 1이 있다면 mines\[x\]\[y\]에 1인 원소들의 개수를 적어주면 된다.

그럼 정답은

{% raw %}

```
[[1, 1, 3, 2],
 [3, 4, 5, 3],
 [3, 5, 6, 4],
 [3, 5, 5, 3]]
```

{% endraw %}

## 3. 디자인 패턴

(  1  )은/는 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별한다. 

구현뿐 아니라 추상화도 독립적 변경이 필요할 때 브리지 패턴을 사용한다.
기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용하며,
새로운 인터페이스를 정의하여 기존 프로그램의 변경 없이 기능을 확장할 수 있다.

 

(  2  )은/는 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달해주는 패턴이다.
일대다 관계를 가지며, 주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다.

1. **Bridge**
2. **Observer**

[참고 블로그](https://skyjava93.tistory.com/entry/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-2-%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4) 

## 5. 네트워크

첫번째 네트워크 주소가 192.168.1.0/26일때 FLSM 3개로 분할했을때 두번째 네트워크 브로드캐스드 IP를 10진수로 변환한 값을 작성하시오.

풀이) 끝에 26은 26비트를 의미함. 총 32비트 중 6비트는 호스트를 위한 비트이다. 2^6개 단위루 분할하면

* 첫번째 서브넷 : (앞자리 생략) 0 ~ 63
* 두번째 서브넷 : 64 ~ 127
* 세번째 서브넷 : 128 ~ 191

브로드캐스트 IP는 서브넷에서 마지막 주소를 의미한다(참고로 첫번째 주소는 네트워크 주소를 의미). 정답은 ~~~.127이다.	

## 6. 테스트

![image-20241014210415921](/images/2024-10-14-22년3회/image-20241014210415921.png)

경계값 분석

## 8. 용어

(   1   ) 은/는 보안학적 측면에서 기술적인 방법이 아닌 사람들간의 기본적인 신뢰를 기반으로 사람을 속여 비밀 정보를 획득하는 기법이다.

 **사회공학**

(   2   ) 은/는 빅데이터(Big Data)와 비슷하면서도 구조화돼 있지 않고, 더는 사용하지 않는 ‘죽은’ 데이터를 의미한다. 일반적으로 정보를 수집해 저장한 이후 분석이나 특별한 목적을 위해 활용하는 데이터가 아니며, 저장공간만 차지하고 이러한 이유로 심각한 보안 위험을 초래할 수 있다.

**다크데이터**

## 10. 용어

(     ) 은/는 **머신러닝** 기술을 이용하여 IT 시스템에서 발생하는 대량의 로그를 통합관리 및 분석하여 사전에 위협에 대응하는 보안 솔루션이다.

서로 다른 기종의 **보안**솔루션 로그 및 **이벤트**를 중앙에서 통합 수집하여 분석할 수 있으며, 네트워크 상태의 monitoring 및 이상징후를 미리 감지할 수 있다.

- 네트워크 이기종 장비 간 로그의 상관관계 분석
- 이상징후의 행위 기반 및 문맥 기반 분석 기능
- 각 로그의 상관관계를 조건식에 따라 검색하여 분석이 가능
- 이벤트 및 로그의 이상패턴을 인식해 잠재적 위협이 발생시 알림 기능

정답 : **SIEM**(Security Information and Event Management)

## 11. 형상 관리

CVS, SVN, GIT

## 13. C

```C
int n;
int k;
int s;
int el = 0;
 
  for(n=6; n<=30; n++){
    s=0;
    k=n/2;
    for(int j=1; j<=k; j++){
      if(n%j==0){
        s=s+j;
      }
    }
    if(s==n){
    el++;
    }
  }
  
  printf("%d", el);
```

1. n에 있는 수를 2로 나눈다.
2. j가 n의 약수라면 계속해서 더한다.
3. 더한 값이 n과 같다면 추가(el : 카운트)

만약 m을 2로 나누지 않았다면 약수를 모두 더한 값이 되겠지만 2로 나누었으므로 자기 자신을 제외한 약수들의 합이 된다.

즉 6~30 중 완전수의 개수를 찾으면 된다.

* 유클리드 오일러 정리

  만약 $2^{p} - 1$이 소수라면 $2^{p-1} * (2^{p}-1)$은 완전수이다.

완전수는 6, 28로 정답은 2

## 14. 용어

(  1  )은/는 프로세서(processor) 안에 **독립적인 보안 구역**을 따로 두어 중요한 정보를 보호하는 ARM사에서 개발한 하드웨어 기반의 보안 기술로 프로세서(processor) 안에 독립적인 보안 구역을 별도로 하여, 중요한 정보를 보호하는 하드웨어 기반의 보안 기술이다.

 **TrustZone**

(  2  )은/는 사용자들이 사이트에 접속할 때 주소를 잘못 입력하거나 **철자를 빠뜨리는 실수**를 이용하기 위해 **유사한 유명 도메인을 미리 등록**하는 일로 URL 하이재킹(hijacking)이라고도 한다.

**typosquatting**

## 15. 용어


(    )은/는 **여러 개의 사이트에서 한번의 로그인**으로 여러가지 다른 사이트들을 자동적으로 접속하여 이용하는 방법을 말한다. 일반적으로 서로 다른 시스템 및 사이트에서 각각의 사용자 정보를 관리하게 되는데 이때 **하나의 사용자 정보**를 기반으로 **여러 시스템을 하나의 통합 인증을 사용**하게 하는 것을 말한다. 

즉 하나의 시스템에서 인증을 할 경우 타 시스템에서는 인증 정보가 있는지 확인하고 있으면 로그인 처리를 하도록 하고, 없는 경우 다시 통합 인증을 할 수 있도록 만드는 것을 의미한다.

**SSO**(Single Sign-on)

## 16. 스케줄링

![image-20241014212607155](/images/2024-10-14-22년3회/image-20241014212607155.png)

**SJF**(Shortest job first), **Round Robin**(RR), **SRT**(Shortest Remaining Time)

* 선점 스케줄링

  우선순위가 높은 프로세스 빠르게 처리

  많은 오버헤드

  우선순위가 높은 다른 CPU를 뺏을 수 있다.

  선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록이 필요하다.

| RR(Round Robin)                  | FCFS를 선점 형태로 변형한 기법<br />프로세스는 할당된 시간 동안 실행한 후 실행이 완료되지 않으면 다음 프로세스에 CPU를 넘겨주고 큐의 뒤로 배치 |
| -------------------------------- | ------------------------------------------------------------ |
| SRT(Shortest Remaining Time)     | SJF 알고리즘을 선점 형태로 변형한 기법<br />실행중인 프로세스의 남은 시간과 준비상태 큐에 도착한 프로세스의 실행 시간 비교<br />가장 짧은 실행 시간을 요구하는 프로세스에 CPU 할당 |
| MLQ(Multi Level Queue)           | 프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비상태 큐를 사용 |
| MLFQ(Multi Level Feedback Queue) | 특정 그룹의 준비상태 큐에 들어간 프로세스가 다른 준비상태 큐로 이동할 수 없는 다단계큐 기법을 이동할 수 있도록 개선한 기법 |

* 비선점 스케줄링

  프로세스 응답시간 예측이 용이, 일괄 처리 방식에 적합

  중요한 작업이 기다리는 경우가 생긴다.

  | FCFS(First Come First Service)   | 준비상태 큐에 도착한 순서에 따라 차례로 CPU 할당<br />공평성은 유지되지만 중요한 작업이 중요하지 않은 작업을 기다리는 경우 발생 |
  | -------------------------------- | ------------------------------------------------------------ |
  | SJF(Shortest Job First)          | 실행 시간이 짧은 프로세스에 먼저 CPU 할당<br />가장 적은 평균 대기시간을 제공함 |
  | HRN(Highest Response-ratio Next) | 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 기법<br />대기시간과 실행시간을 이용<br />우선순위 계산 결과값이 높은 것부터 우선순위 부여, 대기 시간이 긴 프로세스일 경우 계산 결과값이 높게 나온다. |


## 17. UML

UML은 통합 모델링 언어로써, 시스템을 모델로 표현해주는 대표적인 모델링 언어이다.

 

구성 요소로는 사물, (  1  ), 다이어그램으로 이루어져 있으며, 구조 다이어그램 중, (   2  ) 다이어그램은 시스템에서 사용되는 **객체 타입**을 정의하고, 그들 간의 존재하는 정적인 관계를 다양한 방식으로 표현한 다이어그램이다. 

 

또한 UML 모델링에서 (   3  )은/는 클래스와 같은 기타 모델 요소 또는 컴포넌트가 **구현해야 하는 오퍼레이션 세트**를 정의하는 모델 요소이다.



1. 관계
2. 클래스
3. 인터페이스