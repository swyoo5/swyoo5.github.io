---
layout: single
title:  "12/04 [논문리뷰] Long Short Term Memory Recurrent Neural Network Architectures for Large Scale Acoustic Modeling"
categories: [Programming, python, 논문, LSTM]
tag: [Programming, python, 논문, LSTM]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

 이 포스팅은 논문 Long Short-Term Memory Recurrent Neural Network Architectures for Large Scale Acoustic Modeling(Hasim Sak 외 2인)을 해석하고 요약한 글입니다.



# Long Short Term Memory Recurrent Neural Network Architectures for Large Scale Acoustic Modeling(Hasim Sak)

## Abstract

LSTM은 시간적 순서 그리고 일반적인 RNN보다 그들의 긴 범위의 의존도를 더 정확하게 모델링하도록 디자인된 특별한 RNN 구조이다. 이 논문에서 우리는 음성인식에서 큰 규모의 음향 모델링을 위한 LSTM RNN 구조를 알아볼 것이다. 우리는 최근에 LSTM RNN이 한 기계에서 훈련된 적당한 크기의 모델을 고려한 음향 모델링에 있어서 DNN, 일반적인 RNN보다는 더 효율적이라는 것을 보였다. 우리는 큰 군집의 머신에서 비동기식 SGD 최적화를 이용한 LSTM RNN의 최초의 분산 교육을 소개한다. 우리는 각 LSTM의 계층이 선형의 반복되는 투사층을 가진 2 계층의 LSTM RNN이 음성인식의 최신 모델의 성능을 넘을 수 있다는 것을 보여준다. 이 구조는 다른 모델이 고려한 것보다 모델의 파라미터의 사용을 더 효율적으로 사용하고 빠르게 수렴하며 더 많은 파라미터를 가진 깊은 피드포워드 신경망보다 더 나은 성능을 낸다.

Index Terms : Long Short Term Memory, LSTM, recurrent neural network, RNN, speech recognition, acoustic modeling



# 1. Introduction

말은 다양한 시간 범위에서 복잡한 상관관계가 있는 시변동성 신호이다. RNN은 피드 포워드 신경망보다 시계열 데이터를 모델링하는 더 강력한 도구로 만들어주는 순환 연결을 포함한다. RNN은 손글씨 인식 그리고 언어 모델링과 같은 시퀀스 라벨링 그리고 예측 업무에서 큰 성공을 거두었다. 하지만 심층 신경망이 인정받는 최첨단 기술인 음싱인식을 위한 음향모델링에서 최근데 RNN이 소규모 전화인식 작업 외에는 관심을 받지 못했다. 주목할만한 예외는 Robinson, Graves, Sak의 연구이다.

  DNN은 음향 프레임의 고정된 크기의 sliding window를 작동함으로써 제한된 시간적 모델링만을 제공할 수 있다. DNN은 window 내에 있는 데이터만 모델링 할 수 있고 **다양한 말하기 속도**와 **장기 종속성**을 다루는데는 적합하지 않다. 대조적으로 RNN은 현재 시점의 예측에 영향을 주기 위해 이전 시점의 네트워크 활성화값을 네트워크의 입력으로 제공하는 cycle을 가지고 있다. 이러한 활성화 값들은 원칙적으로 장기간의 시간 문맥 정보를 포함하는 네트워크의 은닉값에 저장돼있다. 이러한 메카니즘은 RNN이 피드 포워드 네트워크에 사용되는 고정된 크기의 window와 같이 정적 window가 아닌 입력 시퀀스 기록에 대해 동적으로 변하는 contextual window를 사용할 수 있게 한다. 특히 RNN의 모델링 약점을 극복한 LSTM 구조는 개념적으로 음향 모델링 작업에 적합하다.

  LSTM과 일반적인 RNN은 성공적으로 다양한 시퀀스 예측과 시퀀스 라벨링 작업에 적용됐다. 언어 모델링에서 일반적인 RNN은 표준 n-gram 모델에서 커다란 perplexity의 감소를 얻어냈고 LSTM RNN 모델은 일반적인 RNN LM을 넘는 향상을 보여줬다. LSTM 모델은 RNN 모델보다 문맥에서 자유로운 언어 그리고 문맥에 의존하는 언어들을 배우는데 더 좋은 성능을 보여줬다.  현재 입력을 위한 결정을 내리기 위해 양방향에서의 입력 시퀀스에서 작동하는 양방향 LSTM (BLSTM) 네트워크는 TIMIT 음성 데이터베이스에서 음향 프레임의 음성 라벨링을 위해 제안되었다. 온라인 그리고 오프라인 손글씨 인식에서 Connectionist Temporal Classification(CTC) 층과 함께 사용되고 분할되지 않은 시퀀스 데이터로부터 훈련을 하는 BLSTM 네트워크는 최신의 Hidden Markov Model(HMM)보다 더 나은 성능을 보여줬다. deep BLSTM 네트워크와 비슷한 기술들이 **자소** 기반 음성인식을 수행하기 위해 제안되었다.

* 자소 : 한 언어의 문자 체계에서 음소를 표시하는 최소의 변별적 단위로서의 문자 혹은 문자 결합

BLSTM 네트워크는 연속적인 대화 음성인식을 위한 다중 스트림 프레임워크에서 음소 예측을 위해 제안되었다. 아키텍쳐의 관점에서 음향 모델링을 위한 DNN의 성공에 이어 deep BLSTM RNN은 CTC 출력층과 함께 결합하고 RNN 변환기 예측 음소 시퀀스는 TIMIT 데이터베이스에서 최첨단 모델의 음소 인식 정확도에 도달한 것으로 나타났다.

  Deep BLSTM RNN은 최근에 복합적인 음성 인식 접근법에서의 DNN보다 더 나은 성능을 보여준다. 복합적인 방식을 사용하여 우리는 단일 머신을 사용하여 훈련된 적당한 크기의 모델을 고려할 때 순환 투사층을 가진 LSTM 아키텍처가 DNN과 대규모 단어 음성 인식을 위한 일반적인 RNN보다 우수하다는 것을 최근에 보여주었다. 이 논문에서 분산 훈련을 사용해 대규모의 음향 모델링을 위한 LSTM RNN 구조에 대해 알아본다. 우리는 각 LSTM 계층이 선형 순환 투사층을 가진 2층 deep LSTM RNN이 더 많은 파라미터를 가진 피드 포워드 신경망을 사용한 강력한 기본 시스템보다 성능이 뛰어남을 보여준다.



## 2. LSTM Network Architectures

### 2.1 Conventional LSTM

LSTM은 순환 은닉층 안에 **memory block**이라고 불리는 특별한 유닛을 포함한다. **memory block**은 정보의 흐름을 통제하는 게이트라고 불리는 특별한 곱셈 단위 외에 네트워크의 시간적 상태를 저장하는 자체 연결이 있는 메모리 셀을 포함한다. 원래의 구조 안에 있는 각 **memory block**은 *input gate*와 *output gate*을 포함한다. *input gate*는 메모리 셀 안의 입력 활성화 값의 흐름을 통제한다. *output gate*는 나머지 네트워크 안의 셀 활성화 값의 출력 흐름을 통제한다.

![lstm 논문리뷰 그림](/images/2023-12-04-LSTM/lstm 논문리뷰 그림.jpg)

그림1: LSTM RNN 단일 메모리 블록이 표시되어있다.

나중에 forget gate가 메모리 블록에 추가된다. 이는 LSTM 모델의 약점을 해결했으며 모델을 연속적인 입력 스트림을 부분 시퀀스로 나누지 않고 처리하는 것을 방지한다. forget gate는 셀의 자체 순환 연결을 통해 셀의 입력으로 추가하기 전에 셀의 내부 상태를 조정한다. 따라서 셀 메모리를 적응적으로 잊어버리거나 재설정한다. 게다가 현대의 LSTM 아키텍쳐는 출력의 정확한 타이밍을 학습하기 위해 내부 셀에서 동일한 셀의 게이트까지 *peephole connections*(엿보기 구멍 : Gate layer들이 cell state를 쳐다보게 만드는 모델)을 포함한다.

  LSTM 네트워크는 t = 1부터 T까지 반복적으로 다음 방정식을 사용하여 네트워크 유닛 활성화를 계산하여 입력시퀀스 x = (x1, ... , xT)에서 출력 시퀀스 y = (y1, ... , yT)로의 매핑을 계산한다.

![lstm 논문리뷰 수식](/images/2023-12-04-LSTM/lstm 논문리뷰 수식.jpg)

W는 가중치 행렬, (Wix는 입력 게이트에서 입력 게이트로의 가중치 행렬) Wic, Wfc, Woc는 peephole connectino을 위한 대각 가중치 행렬, b는 편향 벡터, sigma는 로지스틱 시그모이드 함수, i, f, o, ㅊ는 각각 input, forget, ouput gate, cell activation vector을 의미하며 이 모든것들은 cell output activation vector m과 같은 크기를 가지고 동그란 모양의 연산은 원소별 곱, g, h는 cell input과 cell ouput 활성화 함수로 일반적으로 이 논문에서 tanh, 6번째 수식에 있는 함수는 softmax를 의미한다. 



### 2.2 Deep LSTM

더 깊은 아키텍처를 갖춘 DNN과 마찬가지로 deep LSTM RNN은 음성인식에서 성공적으로 사용된다. Deel LSTM RNN은 다중 LSTM 계층을 쌓음으로써 만들어진다. LSTM RNN은 각 층이 같은 파라미터를 공유하는 시점에 따라 펼쳐진 피드 포워드 신경망으로 간주될 수 있다는 관점에서 이미 심층 아키텍처이다. 모델의 입력이 DNN처럼 여러 비선형 계층을 통과하는 것을 알 수 있다. 그러나 특정 시점의 feature은 해당 시점의 출력에 영향을 미치기 전에 단일 비선형 계층에 의해서만 처리된다. 따라서 deep LSTM RNN의 깊이는 추가적인 의미를 갖는다. 주어진 시점의 네트워크의 입력은 시간을 통한 전파 그리고 lstm 계층 외에 여러 LSTM 계층을 지나간다. RNN의 깊은 계층을 사용하면 네트워크가 입력에 대해 여러 시간 규모에서 학습을 할 수 있다고 주장되어왔었다. Deep LSTM RNN은 표준 LSTM RNN에 비해 다른 이득을 제공한다 : 매개변수를 여러 계층을 통해 공간에 분산시켜 매개변수를 더 잘 사용할 수 있게 한다. 예를 들어 표준 모델의 메모리 크기를 2배로 늘리는 대신 대략 같은 수의 매개변수를 가진 4개의 계층을 가질 수 있다. 이로 인해 입력이 시점당 더 많은 선형 작업을 거치게 된다.



### 2.3 LSTMP- LSTM with Recurrent Projection Layer

표준 LSTM RNN 아키텍처는 입력층, recurrent LSTM층, 출력층을 가지고 있다. 입력층은 LSTM층과 연결되어있다. LSTM층의 순환 연결들은 셀 출력 유닛들에서 셀 입력 유닛, 입력 게이트, 출력 게이트 그리고 망각 게이트까지 직접적으로 연결된다. 또한 셀 출력 유닛들은 네트워크의 출력층에 연결돼있다. 편향을 무시하는 각 메모리 블록에 있는 하나의 셀이 있는 표준 LSTM 네트워크에 있는 파라미터의 총 개수 N은 $N = n_{c} * n_{c} * 4 + n_{i} * n_{c} * 4 + n_{c} * n_{o} + n_{c} * 3$ 으로 계산된다. $n_{c}$는 메모리셀의 개수(이번 경우에는 메모리 블록의 개수), $n_{i}$는 입력 유닛의 개수, $n_{o}$는 출력 유닛의 개수이다. SGD 최적화로 가중치, 시점별로 LSTM 모델의 학습의 계산 복잡도는 O(1)이다. 따라서 시점당 학습 계산복잡도는 O(N)이다. 적당한 수의 입력을 이용한 네트워크의 학습시간은 $n_{c} * (4 * n_{c} + n_{o})$ 요인에 의해 좌우된다. 시간적 맥락 정보를 저장하기 위해 많은 개수의 출력 유닛과 많은 개수의 메모리 셀을 요구하는 작업의 경우 LSTM 모델을 학습하는 것은 계산이 매우 많아지게 된다.

  우리는 표준 아키텍처에 대한 대안으로  LSTM 학습의 계산 복잡도를 해결하기 위해 Long Short Term Memory Projected(LSTMP)을 제안한다. 그림 1에 있는 이 아키텍처는 LSTM층 뒤에 분리된 선형 투사층을 가지고 있다. 순환 연결은 이 순환 투사층부터 LSTM층의 입력까지 연결된다. 네트워크 출력 유닛은 이 순환 층에 연결돼있다. 이 모델의 파라미터의 수는 $n_c * n_r * 4 + n_i * n_{c} * 4 + n_{r} * n_{o} + n_{c} * n_{r} + n_{c} * 3$이다. $n_{r}$은 순환 투사층에 잇는 유닛의 개수이다. 이 경우 모델의 크기와 학습 계산복잡도는 $n_{r} * (4 * n_{c} + n_{o})$ 요인에 의해 영향을 받는다. 따라서 우리는 $n_r \over n_c$배 만큼 매개변수의 개수를 줄일 수 있다. $n_r < n_c$로 세팅함으로써 우리는 모델 메모라 $n_c$를 늘릴 수 있고 순환 연결과 출력층에 있는 매개변수의 수를 통제할 수 있다.

![lstm 논문리뷰 표](/images/2023-12-04-LSTM/lstm 논문리뷰 표.jpg)

  제안된 LSTMP 아키텍처로 네트워크 유닛들의 활성화를 위한 방정식이 약간 바뀌었고 활성화 벡터 $m_{t-1}$ 는 $r_{t-1}$로 대체되었고 다음 수식이 추가되었다.

![rnn 논문리뷰 수식1](/images/2023-12-04-LSTM/rnn 논문리뷰 수식1.jpg)

r은 순환 유닛 활성화값을 의미한다.



### 2.4 Deep LSTMP

deep LSTM과 비슷하게 우리는 별도의 순환 투사층이 쌓여있는 여러 LSTM층이 있는 deep LSTMP를 제안한다. LSTMP는 모델의 메모리가 출력층과 순환 연결로부터 독립적으로 늘릴 수 있게 한다. 하지만 메모리 크기를 늘리는것은 모델이 입력 시퀀스 데이터를 기억하여 오버피팅에 취약하게 만드는 것을 기억해야 한다. 우리는 깊이를 늘려서 DNN이 확인하지 않은 예제에 대해 더 나은 일반화를 할 수 있는 것을 알고있다. 깊이는 훈련 데이터에 대해 과적합하기 힘들게 만든다. 왜냐하면 네트워크의 입력은 많은 비선형 함수를 지나야 하기 때문이다. 이런 동기로 메모리 크기와 모델의 일반화 능력을 기르는 것을 목표로 하는 deep LSTMP 아키텍처를 실험했다.



## 3. Distributed Training : Scaling up to Large Models with Parallelization

우리는 LSTM RNN 아키텍처를 구현하기 위해 GPU보다는 멀티코어 CPU를 선택했다. 이 선택은 CPU의 상대적으로 단순한 구현 복잡도, 디버깅의 용이함 그리고 상용 하드웨어로 만든 클러스터를 사용하는 능력을 기반으로 했다. 행렬연산에서 우리는 Eigen 행렬 라이브러리를 사용했다. 이 템플릿 기반 C++ 라이브러리는 벡터화된 명령어를 사용하는 CPU에서의 행렬 연산을 효율적으로 구현한다. 우리의 구현된 활성화 함수와 행렬을 이용한 기울기 계산은 병렬화에 이점을 얻기 위해 SIMD 명령을 사용한다.

  우리는 truncated BPTT 학습 알고리즘을 사용하여 훈련 발화의 짧은 서브시퀀스에 대한 매개변수의 기울기를 계산한다. 활성화값은 고정된 시점 $T_{bptt}$동안 순방향으로 전파된다. 크로스 엔트로피 그래디언트는 이 하위 시퀀스에 대해 계산되고 시작부분으로 역전파된다. 계산의 효율성을 위해 각 쓰레드는 한 시점에 네개의 발화의 서브시퀀스에서 연산한다. 따라서 행렬의 곱셈은 병렬로 한 시점에 4개 프레임에서 연산할 수 있다. 우리는 ASGD(Asynchronous SGD)를 사용하여네트워크 파라미터를 최적화하고 멀티코어 머신의 여러 스레드에서 매개변수를 비동기적으로 업데이트한다. 이는 배치 크기를 효율적으로 늘리고 주어진 배치에서 프레임의 상관관계를 줄인다. 쓰레드가 파라미터를 업데이트하고 난 뒤 LSTM의 상태를 유지하면서 각 발화의 다음 서브시퀀스를 계속하거나 완료 시 재설정 상태로 새 발화를 시작한다. 각 발화의 마지막 서브시퀀스는 T_{bptt}보다 짧을 수 있지만 전체 길이까지 패딩된다. 단 이러한 패딩프레임에 대해서는 그래디언트가 만들어지지 않는다.

  이 고도로 병렬화된 단일 머신 ASGD 프레임워크는 DNN을 사용한 대규모 ASR에 사용한 규모의 모델에 대해서는 느린것으로 입증되었다. 더 확장하기 위해 단일 머신 워커를 많은 각각 3개의 동기화된 계산 스레드가 있는 여러 별도의 머신들에 복제했다. 각 워커는 LSTM 파라미터를 저장하는 공유, 분산 파라미터 서버로 소통한다. 워커가 미니배치에서 파라미터 그래디언트를 계산할 때 그래디언트 벡터는 분할되고 각각이 그래디언트를 그들의 파라미터와 더하고 새로운 파라미터에 대답하는 **parameter server shard**로 보내진다.

* parameter server : 머신러닝모델에서 학습되는 파라미터들을 저장하고 관리하는 서버이다. 분산학습 환경에서 여러 워커 노드들이 데이터를 사용하여 모델을 학습할 때, 파라미터 서버는 이러한 파라미터들을 효율적으로 관리하는 역할을 한다.
* shard : 대용량의 파라미터를 효율적으로 다루기 위해 파라미터 서버에 저장된 파라미터를 여러 부분으로 나누는 것을 샤딩(sharding)이라고 한다. shard는 나뉜 파라미터 중에서 한 부분을 가리킨다.
* worker : 분산 시스템에서 특정 작업이나 계산을 수행하는 개체를 가리키는 용어이다. 머신러닝에서 대부분 학습 작업을 수행하는 프로세스를 워커라고 부른다. 워커는 분산학습에서 학습을 위한 계산을 수행하는 역할을 하며 이를통해 대규모 데이터셋이나 복잡한 모델에 대한 효율적인 학습이 가능해진다.

parameter server shard 합계 매개변수는 전부 비동기식으로 업데이트된다. 예를 들어 워커로부터 업데이트된 그래디언트는 parameter server의 다른 shard에 다른 순서로 도달할 것이다. 비동기에도 불구하고 우리는 안정적인 근사를 관측할 수 있지만 더 큰 병렬성으로 인한 유효 매치 사이즈의 증가로 인해 예상한 것처럼 학습속도를 감소할 수 밖에 없다.



## 4. Experiments

  우리는 대규모 단어 음성인식 작업인google voice search task에서 LSTM RNN 아키텍처의 성능을 평가하고 비교한다. 우리는 LSTM RNN의 음향 모델링을 위해 복합적인 접근법을 사용한다. 여기서 신경망은 HMM(Hidden Markov Model) state 사후를 추정한다. 우리는 훈련 데이터에서 상태의 상대적인 빈도로 추정된 사전확률을 사용하여 사후확률을 스케일링하여 음향 프레임의 가능도를 얻는다. 상태 빈도를 추정할 때 silence state 수를 2.7배로 가중치를 줄인다.



### 4.1 Systems & Evaluation

모든 네트워크는 3백만개의 익명처리 되거나 손으로 옮겨적은 발화로 이루어진 발화 데이터로 훈련한다. 데이터는 10밀리초마다 계산되는 40차원의 log filterbank energy feature의 25밀리초 프레임으로 표현된다.

* Filter Bank : 음성 처리 및 음성 신호 분석에서 사용되는 신호 처리 기술중 하나이다. 주파수 영역에서 신호를 특정한 대역폭으로 분할하여 각 대역폭의 에너지를 추출하는데 사용된다. 

  일반적으로 음성신호는 여러 주파수의 성분으로 이루어져 있는데 필터뱅크는 다양한 주파수 대역을 나타내기 위해 여러개의 필터를 사용한다. 필터를 적용하여 주파수 영역을 대략적으로 분할하고 각 필터의 출력값을 측정하여 해당 대역폭의 에너지를 추출한다.

발화들은  14247 CD state가 있는 8천5백만개의 매개변수 DNN과 정렬된다. 네트워크의 모든 가중치들은 (-0.02, 0.02)의 균등분포를 따른다. 우리는 네트워크 아키텍쳐와 그것의 구성에 특화된 학습률을 안정적인 수렴을 가져다 주는 가장 큰 값으로 설정하려고 노력한다. 결과적으로 다른 네트워크들의 안정적인 수렴을 위한 학습률은 5e-06에서 1e-05이다. 학습률은 훈련동안 지수적으로 감소한다. 올바른 학습률로 LSTM RNN의 훈련은 안정적인 수렴을 가져다준다.

 ![lstm 논문리뷰 그림1](/images/2023-12-04-LSTM/lstm 논문리뷰 그림1.jpg)

메모리 셀의 활성화 범위를 [-50, 50]으로 클리핑하는것 외에 우리는 다른 유닛, 가중치 또는 추정된 그래디언의 활성화값을 제한하지 않는다.

  훈련하는 동안, 우리는 프레임 정확도를 평가한다. 우리는 200,000개의 프레임의 dev set에 대한 프레임 정확도(음향 프레임의 정확도를 라벨링한 음성 state)를 평가한다. 훈련된 모델들은 음성 인식 시스템에서 22,500개의 수기로 작성되고 익명으로 처리된 발화 테스트 세트를 평가한다. 모든 디코딩 실험에서 우리는 검색 오류를 피하기 위해 wide beam을 사용한다. 2천3백만개의 n-gram으로 크게 가지치기된 5-gram 언어 모델이 포함된 LSTM RNN을 사용하여 첫번째 디코딩을 통과한 후 lattice는 10억개의 n-gram이 포함된 5-gram 엉너 모델을 사용하여 점수를 다시 매겼다.

  LSTM RNN의 입력은 frame stacking이 없는 log filterbank energy feature이다. 미래에서 온 프레임 정보가 현재 프레임이 더 나은 결정을 하는 것을 돕기때문에 우리는 출력 HMM state 라벨을 5프레임 지연시킨다. 우리는 역전파 도중의 각 발화의 첫 5프레임의 에러를 계산하지 않고 우리는 5개의 시점동안 각 발화의 마지막 프레임을 반복한다.



### 4.2 Results

표 1에서 우리는 다양한 LSTM과 LSTMP RNN 아키텍처의 결과들을 요약했다. 우리는 단일 계층의 일반적인 LSTM RNN이 대규모 음향 모델링 작업에서 성능이 좋지 못한것을 관측했다. 2층 LSTM RNN의 경우 성능이 향상됐지만 아직 좋지 않다. 5층 LSTM RNN은 성능이 가장 좋은 모델이었다. 7층 LSTM RNN은 훈련시키기 어려웠고 모델은 훈련 하루가 지난 후에야 수렴하기 시작했다. 표에서 단일 계층의 LSTMP RNN 모델과 많은 개수의 메모리셀은 훈련 데이터를 과적합하는 경향을 보였다. LSTMP RNN 계층의 수를 늘리는 것은 이런 저장의 문제를 완화시키는 것 처럼 보였고 held out 데이터의 더 나은 일반화를 가져다줬다. LSTM RNN 모델은 5층 LSTM RNN 모델보다 약간 나은 결과를 보여줬다. 층을 늘리거나 메모리 셀을 늘림으로써 LSTM RNN 모델의 파라미터 수를 1300만개보다 많이 늘리는 것은 성능 향상을 가져다 주지 않았다.

  그림 3은 다양한 LSTM과 LSTMP 아키텍처의 훈련데이터, held out data의 프레임 정확도를 비교한다. 2048개의 많은 메모리 셀을 가진 LSTMP RNN 아키테처의 과적합 문제는 명확하게 보인다. LSTMP RNN 아키텍처는 LSTM RNN 아키텍처보다 빨리 수렴한다. 계층을 더 많이 가지는 것이 일반화에 도움을 주지만 훈련하기가 힘들고 수렴이 느린 것이 명확하다.

  표 2는 모델 매개변수의 깊이나 수에 따라 deep LSTMP RNN 아키텍처를 가진 네트워크의 성능이 어떻게 변하는지 보여준다. 파라미터의 개수를 1300만개보다 많이 증가시키면 성능을 향상시키지 않는다. 대체로 성능을 저하시키지 않고 파라미터의 수를 감소할 수도 있었다. 각 층이 800개의 셀과 512개의 순환 투사층을 가진 2층의 deep LSTMP RNN 아키텍처 48시간 안에 수렴했고 독립적인 테스트 셋에서 10.9%의 WER(단어 오류율)을 제공했다. 이 모델을 100시간 훈련하니 WER이 10.7%로 개선됐고 200시간 훈련하니 10.5%로 개선됐다. 대조적으로 8500만개의 파라미터를 가진 가장 좋은 DNN모델은 같은 beam에서 그리고 몇주동안 훈련을 한 결과 11.3%였다.



## 5. Conclusions

대규모 음향 모델링에서 deep LSTM RNN 아키텍처는 최신의 성능을 달성함을 보였다. 제안된 deep LSTMP RNN 아키텍처는 표준 LSTM 네트워크와 DNN보다 성능이 좋았고 큰 네트워크 훈련에 필요한 계산 효율성을 해결함으로써 모델 파라미터의 효율적인 사용을 만들 수 있었다. 또한 ASGD 분산 훈련을 사용함으로써 LSTM RNN 모델이 빠르게 훈련될 수 있음을 처음으로 보였다.



# Summary

LSTM RNN 아키텍처가 대규모 음향 모델링에서 최첨단 성능을 발휘할 수 있었다. 또한 이 논문에서 LSTM RNN을 사용하여 Google 음성 검색 작업에서 대규모 어휘 음성 인식 작업을 수행하는 방법을 설명하고 분산 훈련을 위한 비동기적 확률적 경사 하강 최적화의 효과를 보여준다.

